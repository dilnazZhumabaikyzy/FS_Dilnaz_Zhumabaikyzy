import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.*;

class CommandArgsException extends Exception {
    public CommandArgsException(String message) {
        super(message);
    }
}

public class FS {
    //Константы для Команд
    public static final String LIST_FILES_DIRECTORIES = "ls";
    public static final String LIST_PY_FILES = "ls_py";
    public static final String IS_DIRECTORY = "is_dir";
    public static final String DEFINE_TYPE = "define";
    public static final String READ_PERMISSIONS = "readmod";
    public static final String SET_PERMISSIONS = "setmod";
    public static final String CAT_CONTENT = "cat";
    public static final String APPEND_LINE = "append";
    public static final String CREATE_BACKUP = "bc";
    public static final String LONGEST_WORD = "greplong";
    public static final String HELP_COMMAND = "help";
    public static final String EXIT_COMMAND = "exit";


    //Списки для хранения команд по категориям: команды с 1, 2 и 3 словами
    public static final List<String> ONE_WORD_COMMANDS = new ArrayList<>();
    public static final List<String> TWO_WORD_COMMANDS = new ArrayList<>();
    public static final List<String> THREE_WORD_COMMANDS = new ArrayList<>();


    private static final String HELPER_MSG = "MyFS 1.0 команды: \n"
            + "ls <path>               выводит список всех файлов и директорий для `path`\n"
            + "ls_py <path>            выводит список файлов с расширением `.py` в `path`\n"
            + "is_dir <path>           выводит `true`, если `path` это директория, в других случаях `false`\n"
            + "define <path>           выводит `директория` или `файл` в зависимости от типа `path`\n"
            + "readmod <path>          выводит права для файла в формате `rwx` для текущего пользователя\n"
            + "setmod <path> <perm>    устанавливает права для файла `path`\n"
            + "cat <path>              выводит контент файла\n"
            + "append <path>           добавляет строку `# Autogenerated line` в конец `path`\n"
            + "bc <path>               создает копию `path` в директорию `/tmp/${date}.backup` где, date - это дата в формате `dd-mm-yyyy`\n"
            + "greplong <path>         выводит самое длинное слово в файле\n"
            + "help                    выводит список команд и их описание\n"
            + "exit                    завершает работу программы\n";
    private static final String EXIT_MSG = "Goodbye";
    private static final String FOOTER_STRING = "# Autogenerated line";
    private static boolean isExit = false;

    static {
        ONE_WORD_COMMANDS.add(HELP_COMMAND);
        ONE_WORD_COMMANDS.add(EXIT_COMMAND);

        TWO_WORD_COMMANDS.add(LIST_FILES_DIRECTORIES);
        TWO_WORD_COMMANDS.add(LIST_PY_FILES);
        TWO_WORD_COMMANDS.add(IS_DIRECTORY);
        TWO_WORD_COMMANDS.add(DEFINE_TYPE);
        TWO_WORD_COMMANDS.add(READ_PERMISSIONS);
        TWO_WORD_COMMANDS.add(CAT_CONTENT);
        TWO_WORD_COMMANDS.add(APPEND_LINE);
        TWO_WORD_COMMANDS.add(CREATE_BACKUP);
        TWO_WORD_COMMANDS.add(LONGEST_WORD);

        THREE_WORD_COMMANDS.add(SET_PERMISSIONS);
    }


    //Проверяет существует ли файл по указанному path
    private static void checkFileExists(File file) throws FileNotFoundException {
        if (!file.exists()) {
            throw new FileNotFoundException("Файл не найден");
        }
    }
    private static File[] getListOfFiles(File file) {
        return file.listFiles();
    }

    private static List<String> getArgs(String command) {
        String[] args = command.split(" ");
        return Arrays.stream(args).toList();
    }

    //Определяет первое слово, то есть саму команду и проверяет ее категорию и допустимое колицествое аргументов.
    //Если все правильно, возвращает команду.
    private static String getString(List<String> commandArgs) throws CommandArgsException {
        String command = commandArgs.get(0);

        if (ONE_WORD_COMMANDS.contains(command)) {
            //Handle one-word commands
            if (commandArgs.size() != 1) {
                throw new CommandArgsException("Недопустимое количество аргументов для " + command);
            }
        } else if (TWO_WORD_COMMANDS.contains(command)) {
            //Handle two-word commands
            if (commandArgs.size() != 2) {
                throw new CommandArgsException("Недопустимое количество аргументов для " + command);
            }
        } else if (THREE_WORD_COMMANDS.contains(command)) {
            //Handle three-word commands
            if (commandArgs.size() != 3) {
                throw new CommandArgsException("Недопустимое количество аргументов для " + command);
            }
        } else {
            throw new CommandArgsException("Неопознанная команда: " + command);
        }
        return command;
    }

    //Вызывает соответсвующие методы к командам
    //Итерации с циклом по спискам заменены на стримы
    private static void executeCommand(String command, List<String> arguments) throws Exception {
        switch (command) {
            case LIST_FILES_DIRECTORIES -> listDirectory(new File(arguments.get(0)));
            case LIST_PY_FILES -> listPythonFiles(new File(arguments.get(0)));
            case HELP_COMMAND -> help();
            case IS_DIRECTORY -> isDirectory(arguments.get(0));
            case DEFINE_TYPE -> define(arguments.get(0));
            case READ_PERMISSIONS -> printPermissions(new File(arguments.get(0)));
            case SET_PERMISSIONS -> setPermissions(new File(arguments.get(0)), arguments.get(1));
            case CAT_CONTENT -> printContent(new File(arguments.get(0)));
            case APPEND_LINE -> appendFooter(arguments.get(0));
            case LONGEST_WORD -> printLongestWord(new File(arguments.get(0)));
            case CREATE_BACKUP -> createBackup(arguments.get(0));
            case EXIT_COMMAND -> {
                exit();
                isExit = true;
            }
        }
    }

    public static String getExtension(String fileName) {
        int positionOfDot = fileName.lastIndexOf('.');
        return positionOfDot != -1 ? fileName.substring(positionOfDot) : "";
    }


    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        help();

        while (!isExit) {
            try {
                System.out.print("> ");
                String input = scanner.nextLine();
                List<String> commandArgs = getArgs(input);
                String command = getString(commandArgs);

                List<String> arguments = commandArgs.subList(1, commandArgs.size());
                executeCommand(command, arguments);
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }

        }
    }

    //Методы для команд
    public static void listDirectory(File file) throws FileNotFoundException {
        checkFileExists(file);
        File[] files = getListOfFiles(file);
        if (files == null) return;

        Arrays.stream(files)
                .map(File::getName)
                .forEach(name -> System.out.print(name + " "));

        System.out.println();
    }


    public static void listPythonFiles(File file) throws FileNotFoundException {
        checkFileExists(file);
        File[] files = getListOfFiles(file);
        if (files == null) return;

        Arrays.stream(files)
                .map(File::getName)
                .filter(name -> getExtension(name).equals(".py"))
                .forEach(name -> System.out.print(name + " "));

        System.out.println();
    }

    public static void isDirectory(String path) {
        System.out.println(new File(path).isDirectory());
    }

    public static void define(String path) throws FileNotFoundException {
        File file = new File(path);
        checkFileExists(file);
        System.out.println(file.isDirectory() ? "directory" : "file");
    }

    public static void printPermissions(File file) throws FileNotFoundException {
        checkFileExists(file);
        String permissions = (file.canRead() ? "r" : "-") + (file.canWrite() ? "w" : "-") + (file.canExecute() ? "x" : "-");

        System.out.println(permissions);
    }

    public static void setPermissions(File file, String permissions) throws FileNotFoundException {
        checkFileExists(file);
        System.out.println("Setting Permissions to " + file.getName() + "\nPermissions: " + permissions);
        if (permissions.length() >= 3) {
            boolean isReadable = permissions.charAt(0) == 'r';
            boolean isWritable = permissions.charAt(1) == 'w';
            boolean isExecutable = permissions.charAt(2) == 'x';

            if (isReadable) {
                boolean setReadableSuccess = file.setReadable(true);
                if (!setReadableSuccess) {
                    System.err.println("Не удалось сделать файл доступным для чтения.");
                }
            }

            if (isWritable) {
                boolean setWritableSuccess = file.setWritable(true);
                if (!setWritableSuccess) {
                    System.err.println("Не удалось сделать файл доступным для записи.");
                }
            }

            if (isExecutable) {
                boolean setExecutableSuccess = file.setExecutable(true);
                if (!setExecutableSuccess) {
                    System.err.println("Не удалось установить файл как исполняемый.");
                }
            }
        }
    }

    public static void printContent(File file) throws Exception {
        checkFileExists(file);
        Scanner scanner = new Scanner(file);

        while (scanner.hasNextLine()) {
            System.out.println(scanner.nextLine());
        }

        scanner.close();
    }

    public static void appendFooter(String path) throws Exception {
        FileWriter fw = new FileWriter(path, true);
        BufferedWriter bw = new BufferedWriter(fw);
        bw.write(FOOTER_STRING);
        bw.newLine();
        bw.close();
        fw.close();
    }

    public static void createBackup(String path) throws Exception {
        String currentDate = new SimpleDateFormat("dd-MM-yyyy").format(new Date());
        Path filePath = Paths.get(path);
        Path backupDir = filePath.resolve("tmp");
        Path backupPath = backupDir.resolve(currentDate + ".backup");


        if (!Files.exists(backupDir)) {
            Files.createDirectories(backupDir);
        }

        Files.copy(filePath, backupPath);
    }

    public static void printLongestWord(File file) throws Exception {
        Scanner scanner = new Scanner(file);
        String longestWord = "";

        while (scanner.hasNextLine()) {
            String line = scanner.nextLine();
            String[] words = line.split("\\s+");

            for (String word : words) {
                if (word.length() > longestWord.length()) {
                    longestWord = word;
                }
            }
        }

        scanner.close();

        if (!longestWord.isEmpty()) {
            System.out.println("Самое динное слово в файле: " + longestWord);
        } else {
            System.out.println("Файл пуст");
        }
    }

    public static void help() {
        System.out.println(HELPER_MSG);
    }

    public static void exit() {
        System.out.println(EXIT_MSG);
    }

}

