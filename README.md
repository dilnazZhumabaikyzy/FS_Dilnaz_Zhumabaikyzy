# Introduction
**Улучшения которые были рекомендованы:**
1. Вывести команды в константы
  - пример: public static final String LIST_FILES_DIRECTORIES = "ls";
  - и все остальные 11 комманд
2. Реализовать итерацию по спискам со стримами
  - пример: Arrays.stream(files)
                  .map(File::getName)
                  .forEach(name -> System.out.print(name + " "));
3. Обрабатывать исключения 
  - реализовала метод checkFileExists для несуществующих файлов
  - добавила IllegalArgumentException для метода setPermissions для некоретных разрешений

**Улучшения которые были дополнительно добавлены:**
1. Списки для хранения команд по категориям: команды с 1, 2 и 3 словами для оптимизации проверки допустимого количества аргументов для команд
    - ONE_WORD_COMMAND, TWO_WORD_COMMANDS, HREE_WORD_COMMANDS 
2. Метод getString
    - Определяет первое слово, то есть саму команду и проверяет ее категорию и допустимое колицествое аргументов.
    - Если все правильно, возвращает команду.
      
# Проверяем программу
#### Команда *ls <path>* выводит список всех файлов и директорий для path
```
> ls .
.idea CommandArgsException.class FS.class fs.iml test.py
```
#### Команда *ls_py <path>*  выводит список файлов с расширением `.py` в `path`
```
> ls_py .
test.py
```
#### Команда *is_dir <path>* выводит `true`, если `path` это директория, в других случаях `false`
```
> is_dir .
true
> is_dir test.py
false
```
#### Команда *define <path>* выводит `директория` или `файл` в зависимости от типа `path`
```
> define .
directory
> define test.py
file
```
#### Команда *readmod <path>*  выводит права для файла в формате `rwx` для текущего пользователя
```
> readmod test.py
rwx
```
#### Команда *setmod <path> <perm>*    устанавливает права для файла `path`
```
> setmod test.py r-x
Setting Permissions to test.py
Permissions: r-x
```
*все сделано как в видео уроке, но у меня ничего не меняется. Хотя ошибки не вызываются, так же добавила проверки для каждого рарешения:*
```
 if (isReadable) {
                boolean setReadableSuccess = file.setReadable(true);
                if (!setReadableSuccess) {
                    System.err.println("Не удалось сделать файл доступным для чтения.");
                }
            }
```
*Но в консоли ничего не показывает, что означало б все работает. Но при повторной проверке через readmod для test.py, разрешения файла остаются прежними*
*Запускала консоль от имени администратора - не помогло. Может ли проблема быть, в том что я работаю не с linux, а Windows?*
#### Команда *cat <path>*   выводит контент файла
```
> cat test.py
#the longest word in this file is pneumonoultramicroscopicsilicovolcanoconiosis
```
#### Команда *append <path>*  добавляет строку `# Autogenerated line` в конец `path`
```
> append test.py
> cat test.py
#the longest word in this file is pneumonoultramicroscopicsilicovolcanoconiosis

# Autogenerated line
```
#### Команда *bc <path>*  создает копию `path` в директорию `/tmp/${date}.backup` где, date - это дата в формате `dd-mm-yyyy`
```
> bc test.py
C:\Users\aestg\Desktop\practice\java\jusan\fs\out\production\fs\test.py\tmp
```
*Также не работает. Не поняла, зачем он принтин в аут непонятную путь. Как  я поняла код должен был создать в tmp файл с раширением .backup
Но в аутпуте я вижу путь самого оригинального файла(то есть test.py) и дальше \tmp как указала выше. При жтом ничего не создается в tmp.*

*Если запустить команду*
> bc .
*с указанием директорий, а не файла, то в tmp создается папка 08-01-2024.backup.*

#### Команда *greplong <path>*   выводит самое длинное слово в файле
```
> greplong test.py
Самое динное слово в файле: pneumonoultramicroscopicsilicovolcanoconiosis
```
#### Команда *help* выводит список команд и их описание
```
> greplong test.py
Самое динное слово в файле: pneumonoultramicroscopicsilicovolcanoconiosis
...
```
#### Команда *exit* 
```
> exit
Goodbye
```



   
